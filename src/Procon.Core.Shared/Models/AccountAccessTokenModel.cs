using System;
using System.Security.Cryptography;
using System.Text;
using Newtonsoft.Json;

namespace Procon.Core.Shared.Models {
    /// <summary>
    /// A temporary access token that can be used in place of a password
    /// </summary>
    /// <remarks>
    ///     <para>A token is generated by deriving a password from (hash of users current pass, password supplied in command line, external identifer (like ip/hostname), salt)</para>
    ///     <para>A token is validated by checking the derivation of the three generated items matches the token</para> 
    /// </remarks>
    [Serializable]
    public class AccountAccessTokenModel : CoreModel, IDisposable {
        /// <summary>
        /// The id of the session
        /// </summary>
        public Guid Id { get; set; }

        /// <summary>
        /// The owner account
        /// </summary>
        [JsonIgnore]
        public AccountModel Account { get; set; }

        /// <summary>
        /// The bcrypt encrypted token
        /// </summary>
        [JsonIgnore]
        public String TokenHash { get; set; }

        /// <summary>
        /// When the token was last successfully authenticated against. Tokens that have not been
        /// touched for longer than 48 hours are removed and the user will need to authenticate again.
        /// </summary>
        public DateTime LastTouched { get; set; }

        /// <summary>
        /// The maximum age in seconds that a token can go without being touched before it is considered expired.
        /// </summary>
        public int ExpiredWindowSeconds {
            get { return _expiredWindowSeconds; }
            set { _expiredWindowSeconds = Math.Abs(value); }
        }

        private int _expiredWindowSeconds;

        /// <summary>
        /// Initializes the basics, like a new guid.
        /// </summary>
        public AccountAccessTokenModel() {
            this.Id = Guid.NewGuid();
            this.LastTouched = DateTime.Now;

            this.ExpiredWindowSeconds = 172800;
        }

        /// <summary>
        /// Generates random salt.
        /// </summary>
        /// <returns>Salted random, generated style.</returns>
        protected byte[] GenerateSalt(int length) {
            byte[] salt = new byte[length];

            using (RNGCryptoServiceProvider random = new RNGCryptoServiceProvider()) {
                random.GetBytes(salt);
            }

            return salt;
        }

        /// <summary>
        /// Hashes some data with SHA512. We do this because bcrypt has a maximum 72 char password and 
        /// we're essentially mixing two hashed passwords together with a bit of byo pepper.
        /// </summary>
        /// <param name="data">The data to be hashed.</param>
        /// <returns>The hash</returns>
        public String ShaHash(String data) {
            String hash = null;

            using (var sha = new SHA512Managed()) {
                hash = BitConverter.ToString(sha.ComputeHash(Encoding.UTF8.GetBytes(data))).Replace("-", "");
            }

            return hash;
        }

        /// <summary>
        /// Generates a new token from the available data
        /// </summary>
        /// <param name="identifer">Essentially pepper, but from context of the user. It's someting known about the users connection, like an IP.</param>
        /// <returns>The token that can be used to authenticate.</returns>
        public String Generate(String identifer) {

            // Generate a random string for our access token.
            String token = null;

            if (this.Account != null && String.IsNullOrEmpty(this.Account.PasswordHash) == false && String.IsNullOrEmpty(identifer) == false) {
                this.LastTouched = DateTime.Now;

                // Generate a random string for our access token.
                token = Convert.ToBase64String(this.GenerateSalt(64));
                
                // The hash is equal to our generated token + the accounts current hash
                // The access token is useless if: The password is changed OR the password is set to the same and the hash is regenerated
                this.TokenHash = BCrypt.Net.BCrypt.HashPassword(this.ShaHash(token + this.Account.PasswordHash + identifer), BCrypt.Net.BCrypt.GenerateSalt());
            }

            return token;
        }

        /// <summary>
        /// Validates the token identifer and token against this access token
        /// </summary>
        /// <param name="id">The identifier of the access token</param>
        /// <param name="token">The plain text token given to the user</param>
        /// <param name="identifer">The identifying information about the user</param>
        /// <returns>True if the token is valid, false if the token is invalid.</returns>
        public bool Authenticate(Guid id, String token, String identifer) {
            bool authenticated = false;

            // 1. If this is the id of the token the user wanted to authenticate against
            // 2. If the token has not expired
            // 3. If the supplied token is not empty or null
            // 4. If the supplied identifier is not null or empty
            // 5. If.. for some reason.. we don't have a token for them to validate against..
            // 6. If we don't know who owns this token?
            // 7. If the owner does not have a password hash set (accounts don't require a password hash set, but we need one here)
            if (this.Id == id && this.LastTouched > DateTime.Now.AddSeconds(-1 * this.ExpiredWindowSeconds) && String.IsNullOrEmpty(token) == false && String.IsNullOrEmpty(identifer) == false && String.IsNullOrEmpty(this.TokenHash) == false && this.Account != null && String.IsNullOrEmpty(this.Account.PasswordHash) == false) {
                authenticated = String.CompareOrdinal(this.TokenHash, BCrypt.Net.BCrypt.HashPassword(this.ShaHash(token + this.Account.PasswordHash + identifer), this.TokenHash)) == 0;

                if (authenticated == true) {
                    this.LastTouched = DateTime.Now;
                }
            }

            return authenticated;
        }

        public void Dispose() {
            this.Id = Guid.Empty;
            this.Account = null;
            this.TokenHash = null;
        }
    }
}
